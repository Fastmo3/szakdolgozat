\Chapter{Mellékletek}
\Section{A minta BPEL folyamat forráskódja}
\begin{verbatim}
<!-- hworld BPEL Process [Generated by the Eclipse BPEL Designer]  -->
<!-- Date: Sat Nov 09 19:05:12 CET 2019 -->

<bpel:process name="hworld"
				 targetNamespace="http://eclipse.org/bpel/sample"
				 suppressJoinFailure="yes"
				 xmlns:tns="http://eclipse.org/bpel/sample"
				 xmlns:bpel="http://docs.oasis-open.org/wsbpel/2.0/process/executable"
				 >
		<!-- Import the client WSDL -->
	<bpel:import location="hworldArtifacts.wsdl" namespace="http://eclipse.org/bpel/sample" 
					importType="http://schemas.xmlsoap.org/wsdl/" />
					
		<!-- ================================================================= -->         
		<!-- PARTNERLINKS                                                      -->
		<!-- List of services participating in this BPEL process               -->
		<!-- ================================================================= -->         
		<bpel:partnerLinks>
				<!--
				The 'client' role represents the requester of this service. It is 
				used for callback. The location and correlation information associated
				with the client role are automatically set using WS-Addressing.
				-->
				<bpel:partnerLink name="client"
										 partnerLinkType="tns:hworld"
										 myRole="hworldProvider"
										 partnerRole="hworldRequester"
										 />
		</bpel:partnerLinks>
	
		<!-- ================================================================= -->         
		<!-- VARIABLES                                                         -->
		<!-- List of messages and XML documents used within this BPEL process  -->
		<!-- ================================================================= -->         
		<bpel:variables>
				<!-- Reference to the message passed as input during initiation -->
				<bpel:variable name="input"
									messageType="tns:hworldRequestMessage"/>
									
				<!-- Reference to the message that will be sent back to the 
						 requester during callback
						 -->
				<bpel:variable name="output"
									messageType="tns:hworldResponseMessage"/>
		</bpel:variables>

		<!-- ================================================================= -->         
		<!-- ORCHESTRATION LOGIC                                               -->
		<!-- Set of activities coordinating the flow of messages across the    -->
		<!-- services integrated within this business process                  -->
		<!-- ================================================================= -->         
		<bpel:sequence name="main">
				
				<!-- Receive input from requestor. 
						 Note: This maps to operation defined in hworld.wsdl 
						 -->
				<bpel:receive name="receiveInput" partnerLink="client"
								 portType="tns:hworld"
								 operation="initiate" variable="input"
								 createInstance="yes"/>
				<bpel:empty name="FIX_ME-Add_Business_Logic_Here"></bpel:empty>
				<!-- Asynchronous callback to the requester.
						 Note: the callback location and correlation id is transparently handled 
						 using WS-addressing.
						 -->
				<bpel:invoke name="callbackClient" 
								partnerLink="client"
								portType="tns:hworldCallback"
								operation="onResult" 
								inputVariable="output"
								/>
		</bpel:sequence>
</bpel:process>
\end{verbatim}
\Section{LP feladat Python kódja}
A kapacitás vizsgálatot végző rutin az alábbi tevékenységeket hajtja végre.
Új LP feladat létrehozása a \texttt{prop} változóba:
\begin{python}
prop = Init_LpProblem(Minimize)
\end{python}
Az optimalizálási probléma változóinak inicializálása:
\begin{python}
tr_vars = LpVariable("Iv", tr_items, lowBound=0, cat='Continuous')
\end{python}
Együtthatók meghatározása és beállítása:
\begin{python}
for pp in places:
	if pp.border == 0:
		costs[ll] = costs[ll] +/- 1
\end{python}
\newpage
A célfüggvény meghatározása:
\begin{python}
Init_lpSum([costs[i] * tr_vars[i] for i in tr_items])
\end{python}
Belső pontok súlyának meghatározása:
\begin{python}
for pp in places:
    if pl.border == 0:
        for e in pl.inputs:
            wgts[e] = wgts[e] + 1
        for e in pl.outputs:
            wgts[e] = wgts[e] - 1
        cnts = 0
\end{python}
Az egyenlőtlenség rendszer együtthatóinak meghatározása:
\begin{python}
Init_lpSum([wgts[i] * tr_vars[i] for i in tr_items]) >= cnts
if pl.border == 1:
    for e in pl.outputs:
        wgts[e] = wgts[e] + 1
    cnts = pl.Q

Init_lpSum([wgts[i] * tr_vars[i] for i in tr_items]) == cnts
if pl.border == 2:
    for e in pl.inputs:
        wgts[e] = wgts[e] + 1
    cnts = -pl.Q
    
Init_.lpSum([wgts[i] * tr_vars[i] for i in tr_items]) <= cnts
for tr in self.transitions:
    for e in tr.inputs:
        wgts[e] = wgts[e] + 1
    for e in tr.outputs:
        wgts[e] = wgts[e] - 1
                
Init_lpSum([wgts[i]*tr_vars[i] for i in tr_items]) == 0
    for e in tr.inputs:
        wgts[e] = wgts[e] + 1
    cnts = tr.C
    
Init_lpSum([wgts[i] * tr_vars[i] for i in tr_items]) <= cnts

if tr.mode == 'AND':
    for e in range(1, len(tr.inputs)):
        Init_lpSum([wgts[i] * tr_vars[i] for i in tr_items]) == 0
    for e in range(1,len(tr.outputs)):
        Init_lpSum([wgts[i]*tr_vars[i] for i in tr_items]) == 0

if tr.mode == 'OR':
    for e in range(1,len(tr.outputs)):
        e1 = tr.outputs[0]
        e2 = tr.outputs[e]
        wgts[e1] =  1
        wgts[e2] =  -1
        Init_p.lpSum([wgts[i]*tr_vars[i] for i in tr_items]) == 0
\end{python}
Az optimalizálási probléma megoldása, majd az eredményeinek a kiírása:
\begin{python}
prob.solve()
prob.print()
\end{python}
\Section{További leképzések}
\section{\texttt{<scope>}}

A gyerek elemek hatókörét lehet vele szabályozni.
\begin{verbatim}
<scope isolated="yes|no"? exitOnStandardFault="yes|no"?
   standard-attributes>
   standard-elements
   <partnerLinks>?
      ... see above under <process> for syntax ...
   </partnerLinks>
   <messageExchanges>?
      ... see above under <process> for syntax ...
   </messageExchanges>
   <variables>?
      ... see above under <process> for syntax ...
   </variables>
   <correlationSets>?
      ... see above under <process> for syntax ...
   </correlationSets>
   <faultHandlers>?
      ... see above under <process> for syntax ...
   </faultHandlers>
   <compensationHandler>?
      ...
   </compensationHandler>
   <terminationHandler>?
      ...
   </terminationHandler>
   <eventHandlers>?
      ... see above under <process> for syntax ...
   </eventHandlers>
   activity
</scope>

Nem generál új elemet, csak a láthatósági, azaz visszacsatolási elemeket adja meg. 
\end{verbatim}
\Section{\texttt{<receive>}}

Egy megfelelő üzenet után engedi a folyamatot továbbhaladni, így várakoztatáshoz használható. A \texttt{<receive>} típusú XML elemekhez tartozó sémaleírás:\\
\begin{verbatim}
<receive partnerLink="NCName"
   portType="QName"?
   operation="NCName"
   variable="BPELVariableName"?
   messageExchange="NCName"?>
   <fromParts>?
      <fromPart part="NCName" toVariable="BPELVariableNm"/>+
   </fromParts>
</receive>
\end{verbatim}
A hálóban ezt egy tranzicióval könnyedén megoldhatjuk, hiszen csak egy specifikus üzenet token kell a továbblépéshez, és a többit addig az előző helyen parkoltatja. 

\Section{\texttt{<reply>}}
Üzenetküldő elem, ami \texttt{<receive>; <onMessage>;<onEvent>} események után léphet akcióba. 
\begin{verbatim}
<reply partnerLink="NCName"
   portType="QName"?
   operation="NCName"
   variable="BPELVariableName"?
   messageExchange="NCName"?>
   <toParts>?
      <toPart part="NCName" fromVariable="BPELVariableNm"/>+
   </toParts>
</reply>
\end{verbatim}
A lekezelése az előző példával analóg módon, annyi különbséggel, hogy a tokenek nem parkolnak, hanem tovább mennek és a tranzíció csak akkor generál új tokent ha üzenetet kap egy ágról.
